package models

import (
	"myproject/api/utils"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

type User struct {
	ID       uint   `gorm:"primary_key" json:"id"`
	Name     string `gorm:"type:VARCHAR" json:"name" form:"name"`
	Email    string `gorm:"type:VARCHAR" json:"email" form:"email"`
	Username string `gorm:"type:VARCHAR" json:"username"`
	Phone    string `gorm:"type:VARCHAR" json:"phone" form:"phone"`

	HashedPassword string `gorm:"type:VARCHAR" json:"hashedPassword"`
	Password       string `gorm:"-" json:"password" form:"password"` // virtual field - do not migrate
	Pin            uint   `json:"pin"`

	ApiKey uuid.UUID `gorm:"type:uuid;default:gen_random_uuid()" json:"apiKey" form:"apiKey"` // generated by the API server
	PubKey string    `gorm:"type:VARCHAR" json:"pubKey" form:"pubKey"`                        // SHA256 public key generated by the app
	Roles  string    `gorm:"type:VARCHAR" json:"roles"`                                       // comma separated list of roles
	// e.g admin, user, technician, service_provider, business_owner, contractor
	Photo string `gorm:"type:VARCHAR" json:"photo" form:"photo"`

	City     string `gorm:"type:VARCHAR" json:"city" form:"city"`
	Province string `gorm:"type:VARCHAR" json:"province" form:"province"`
	Country  string `gorm:"type:VARCHAR" json:"country" form:"country"`

	// communication apps identifiers
	WhatsApp string `gorm:"type:VARCHAR" json:"whatsapp"  form:"whatsapp"` // WhatsApp phone number
	Telegram string `gorm:"type:VARCHAR" json:"telegram"  form:"telegram"` // telegram chat ID
	Signal   string `gorm:"type:VARCHAR" json:"signal"  form:"signal"`     // signal phone number
	Session  string `gorm:"type:VARCHAR" json:"session"  form:"session"`   // session ID

	Day    int    `json:"day" form:"day"`
	Month  int    `json:"month" form:"month"`
	Yob    int    `json:"yob" form:"yob"`
	Gender string `gorm:"type:VARCHAR" json:"gender" form:"gender"`

	Locale string `gorm:"type:VARCHAR" json:"locale" form:"locale"`

	UnlockToken string         `gorm:"type:VARCHAR" json:"unlockToken" form:"unlockToken"`
	Flags       pq.StringArray `gorm:"type:varchar[]" json:"flags"` // flags to control the user

	DataItems []DataItem

	// define a foreign key on BusinessRole.RoleID to User.ID
	BusinessRoles []BusinessRole `gorm:"foreignKey:RoleId" json:"businessRoles,omitempty"`

	CreatedAt time.Time
	UpdatedAt time.Time
}

type Referral struct {
	ID         uint `gorm:"primary_key" json:"id"`
	ReferrerID uint `gorm:"type:BIGINT" json:"referrerId" form:"referrerId"` // user.ID of the referrer
	ReferredID uint `gorm:"type:BIGINT" json:"referredId" form:"referredId"` // user.ID of the new referred user

	// can be used in a link to find the referral record
	Code string `gorm:"type:VARCHAR"  json:"code" form:"code"`

	Name  string `gorm:"type:VARCHAR" json:"name" form:"name"`
	Email string `gorm:"type:VARCHAR" json:"email" form:"email"`
	Phone string `gorm:"type:VARCHAR" json:"phone" form:"phone"`

	// 'new,emailSent,registered'
	Status string `gorm:"type:VARCHAR;default:'new'" json:"status" form:"status"`

	// number of tokens to reward, could be based on the referral code
	Reward uint `gorm:"default:1" json:"reward"`

	// has the reward been awarded, happens when the referred person buys credits/tokens to request
	// or respond to service requests
	Awarded bool `gorm:"default:false" json:"awarded"`

	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserApp struct {
	ID      uint   `gorm:"primary_key" json:"id"`
	UserId  uint   `gorm:"type:BIGINT"  json:"userId" form:"userId"`
	Name    string `gorm:"type:VARCHAR" json:"name" form:"name"`
	Version string `gorm:"type:VARCHAR" json:"version" form:"version"`
	Package string `gorm:"type:VARCHAR" json:"package" form:"package"`
	Build   uint   `json:"build" form:"build"`
	Token   string `gorm:"type:VARCHAR" json:"token" form:"token"` //  fcm token

	CreatedAt time.Time
	UpdatedAt time.Time
}

type UserEvent struct {
	ID         uint      `gorm:"primaryKey" json:"id"`
	UserID     uint      `json:"user_id"`
	EventType  string    `json:"event_type"`
	Path       string    `json:"path"`
	Properties string    `json:"properties"` // JSON string
	ClientIP   string    `json:"client_ip"`
	UserAgent  string    `json:"user_agent"`
	CreatedAt  time.Time `json:"created_at"`
}

type Signature struct {
	UserId      uint   `gorm:"type:BIGINT"  json:"userId" form:"userId"`
	SignerId    uint   `gorm:"type:BIGINT"  json:"signerId" form:"signerId"` // user ID of the signer instead of userId
	Signature   string `gorm:"type:VARCHAR" json:"signature" form:"signature"`
	Nonce       string `gorm:"type:VARCHAR" json:"nonce" form:"nonce"`
	AppName     string `gorm:"type:VARCHAR" json:"appName" form:"appName"`
	PackageName string `gorm:"type:VARCHAR" json:"packageName" form:"packageName"`
	Version     string `gorm:"type:VARCHAR" json:"version" form:"version"`
	BuildNumber string `gorm:"type:VARCHAR" json:"buildNumber" form:"buildNumber"`
	FcmToken    string `gorm:"type:VARCHAR" json:"fcmToken" form:"fcmToken"`
}

type LoginRequest struct {
	Name     string `gorm:"type:VARCHAR" json:"name" form:"name"`
	Email    string `gorm:"type:VARCHAR" json:"email" form:"email"`
	Phone    string `gorm:"type:VARCHAR" json:"phone" form:"phone"`
	Token    string `gorm:"type:VARCHAR" json:"token" form:"token"`
	Password string `gorm:"type:VARCHAR" json:"password" form:"password"`
	UserId   uint   `gorm:"type:BIGINT"   json:"userId" form:"userId"`
}

// a list of a users private data for account recovery
// biometric fingerprint hash
// e.g a set of images (mix with other images and they select the one's they recognise)
// public keys e.g. nostr
// a list of place names (mix with other place names and they select the one's they recognise)
//
//	DocumentNumber string `gorm:"type:VARCHAR" json:"documentNumber" form:"documentNumber"`
//	DocumentType   string `gorm:"type:VARCHAR" json:"documentType" form:"documentType"`
type DataItem struct {
	ID     uint   `gorm:"primary_key" json:"id"`
	UserId uint   `gorm:"type:BIGINT"  json:"userId" form:"userId"`
	Kind   string `gorm:"type:VARCHAR" json:"kind" form:"kind"` // fingerprint, face, picture, public key, place name (place of birth), voice print, document type, etc.
	Value  string `gorm:"type:VARCHAR" json:"value" form:"value"`
}

func MigrateUser(db *gorm.DB) error {

	if err := db.AutoMigrate(&User{}); err != nil {
		return err
	}

	if err := db.AutoMigrate(&UserApp{}); err != nil {
		return err
	}

	if err := db.AutoMigrate(&UserEvent{}); err != nil {
		return err
	}

	if err := db.AutoMigrate(&DataItem{}); err != nil {
		return err
	}

	if err := db.AutoMigrate(&Referral{}); err != nil {
		return err
	}

	db.Exec("CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS referral_data_idx on referrals (referrer_id, email, phone)")

	db.Exec("CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS referral_code_idx on referrals (code)")

	//db.Exec("alter table users add column location GEOGRAPHY(POINT,4326)")

	// create a unique index on users email and phone
	db.Exec("CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS user_data_idx on users (email, phone)")

	// users, user_apps and data items should be in the same data shard
	// constrain user_apps to reference users
	//db.Exec("alter table user_apps add constraint user_apps_id_fkey foreign key (user_id) references users(id) on delete cascade")

	// create an index on user data items
	db.Exec("CREATE INDEX CONCURRENTLY IF NOT EXISTS user_data_items_idx on data_items (user_id, kind)")

	// constrain data_items to reference users
	//db.Exec("alter table user_data add constraint user_data_id_fkey foreign key (user_id) references users(id) on delete cascade")
	return nil
}

// HashPassword generates a bcrypt hash for the given password.
func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
	return string(bytes), err
}

// VerifyPassword verifies if the given password matches the stored hash.
func VerifyPassword(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

func (u *User) BeforeCreate(tx *gorm.DB) (err error) {
	// randUUID, _ := uuid.NewRandom()
	// u.ApiKey = randUUID.String()

	if u.Username == "" {
		u.Username = u.Email
	}
	if u.Password == "" {
		// create a random password
		u.Password = utils.GeneratePassword(10)
	}
	if u.Pin == 0 {
		u.Pin = utils.GeneratePin()
	}
	if u.Locale == "" {
		u.Locale = "en_US"
	}

	return nil
}

// runs before create and save
func (u *User) BeforeSave(tx *gorm.DB) error {

	// remove accents from city/province
	// normalise the business location data
	u.City = utils.NormalizeAddress(u.City)
	u.Province = utils.NormalizeAddress(u.Province)
	//b.Country = utils.NormalizeAddress(b.Country)  // do not do this as it changes USA to Usa

	if u.Country == "United States" || u.Country == "Usa" {
		u.Country = "USA"
	}

	u.Phone = utils.FixupPhone(u.Phone)

	if u.Password != "" {
		// hash the password to HashedPassword
		u.HashedPassword, _ = HashPassword(u.Password)
	}

	return nil
}

func (u *User) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"name": u.Name, "email": u.Email, "phone": u.Phone,
		"userId":   u.ID,
		"id":       u.ID,
		"user_id":  u.ID,
		"avatar":   u.Photo,
		"city":     u.City,
		"province": u.Province,
		"country":  u.Country,
		"token":    u.ApiKey,
		"roles":    u.Roles,
	}
}

/*
func (d *User) BeforeCreate(scope *gorm.Scope) error {
	return UserUpdatedBy(d, scope.Get("fiber").(*fiber.Ctx))
}

func (d *User) BeforeUpdate(scope *gorm.Scope) error {
	return UserUpdatedBy(d, scope.Get("fiber").(*fiber.Ctx))
}

func (d *User) BeforeDelete(scope *gorm.Scope) error {
	return UserUpdatedBy(d, scope.Get("fiber").(*fiber.Ctx))
}

func (d *User) AfterFind() error {
	return nil
}

func (d *User) AfterCreate(scope *gorm.Scope) error {
	return nil
}

func (d *User) AfterUpdate(scope *gorm.Scope) error {
	return nil
}

func (d *User) AfterDelete(scope *gorm.Scope) error {
	return nil
}

func (d *User) BeforeSave() error {
	return nil
}

func (d *User) AfterSave() error {
	return nil
}

func (d *User) BeforeDelete() error {
	return nil
}

func (d *User) AfterDelete() error {
	return nil
}

func (d *User) BeforeUpdate() error {
	return nil
}

func (d *User) AfterUpdate() error {
	return nil
}

func (d *User) BeforeCreate() error {
	return nil
}

func (d *User) AfterCreate() error {
	return nil
}

func (d *User) BeforeQuery() error {
	return nil
}

func (d *User) AfterQuery() error {
	return nil
}

func (d *User) BeforeScan() error {
	return nil
}

func (d *User) AfterScan() error {
	return nil
}

func (d *User) GetUser(c *fiber.Ctx) error {

	userId, err :=

}
*/
